(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){


SupCore.system.registerPlugin("typescriptAPI", "FTWEEN", {
  code: "declare var FTWEEN;",
  defs: "// Type definitions for ftween.js\n// https://github.com/florentpoujol/ftween.js\n\n// Exposed in Superpowers by the fTween plugin\n// https://github.com/florentpoujol/superpowers-ftween-plugin\n\n// Origial definitions for Soledad PenadÃ©s's tween.js by: sunetos <https://github.com/sunetos>, jzarnikov <https://github.com/jzarnikov>\n// Definitions: https://github.com/borisyankov/DefinitelyTyped\n\ndeclare module FTWEEN {\n  export var Easing: Easings;\n  export var Interpolation: Interpolations;\n\n  export function getAll(): Tween[];\n  export function removeAll(): void;\n  export function add(tween:Tween): void;\n  export function remove(tween:Tween): void;\n  export function update(time?:number): boolean;\n\n  export class Tween {\n    constructor(object?:Object);\n    from(object:Object): Tween;\n    to(properties:Object, duration?:number): Tween;\n    duration(duration:number): Tween;\n    isRelative(isRelative:boolean): Tween;\n    start(time?:number): Tween;\n    stop(): Tween;\n    pause(): Tween;\n    resume(): Tween;\n    destroy(recurse?:boolean): void;\n    stopChainedTweens();\n    getChainedTweens(): Tween[];\n    removeChainedTweens(tween?: Tween): number;\n    delay(amount:number): Tween;\n    repeat(times:number): Tween;\n    yoyo(enable:boolean): Tween;\n    easing(easing:EasingFunction): Tween;\n    interpolation(interpolation:InterpolationFunction): Tween;\n    chain(...tweens:Tween[]): Tween;\n    onStart(callback?:Callback): Tween;\n    onUpdate(callback?:UpdateCallback): Tween;\n    onPause(callback?:Callback): Tween;\n    onResume(callback?:Callback): Tween;\n    onLoopComplete(callback?:LoopCompleteCallback): Tween;\n    onComplete(callback?:Callback): Tween;\n    onStop(callback?:Callback): Tween;\n    update(time:number): boolean;\n  }\n\n  export interface Callback {\n    (): void;\n  }\n  export interface UpdateCallback {\n    (progression:number): void;\n  }\n  export interface LoopCompleteCallback {\n    (remainingLoops:number): void;\n  }\n\n  export interface EasingFunction {\n    (k:number): number;\n  }\n  export interface InterpolationFunction {\n    (v:number[], k:number): number;\n  }\n\n  export interface Easings {\n    Linear: {\n      None: EasingFunction;\n    };\n    Quadratic: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Cubic: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Quartic: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Quintic: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Sinusoidal: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Exponential: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Circular: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Elastic: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Back: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n    Bounce: {\n      In: EasingFunction;\n      Out: EasingFunction;\n      InOut: EasingFunction;\n    };\n  }\n  \n  export interface Interpolations {\n    Linear: InterpolationFunction;\n    Bezier: InterpolationFunction;\n    CatmullRom: InterpolationFunction;\n\n    Utils: {\n      Linear(p0:number, p1:number, t:number): number;\n      Bernstein(n:number, i:number): number;\n      Factorial(n): number;\n    };\n  }\n}\n"
});

SupCore.system.registerPlugin("typescriptAPI", "fTween", {
  code: "/// <reference path=\"../lib/ftween.d.ts\" />\n\n/**\n* @private\n*/\nvar shortEventNames = [ \"start\", \"pause\", \"resume\", \"update\", \"loopComplete\", \"complete\", \"stop\" ];\n\n/**\n* @private\n*/\nvar eventNames = [ \"onStart\", \"onPause\", \"onResume\", \"onUpdate\", \"onLoopComplete\", \"onComplete\", \"onStop\" ];\n\n/**\n* @private\n*/\nvar copyObject = function(source: Object): any {\n  var dest: any = {};\n  for (var property in source) {\n    dest[ property ] = source[ property ];\n  }\n  return dest;\n}\n\nnamespace fTween {\n\n  /**\n  * The object containing the easing functions segregated into families (ie: `fTween.Easing.Cubic`) and variants (ie: `fTween.Easing.Cubic.In`).\n  */\n  export const Easing = FTWEEN.Easing;\n  \n  /**\n  * The object containing the interpolation functions (ie: `fTween.Interpolation.Cubic`).\n  */\n  export const Interpolation = FTWEEN.Interpolation;\n\n  export class Tween {\n    /**\n    * Returns an instance of `fTween.Tween`.\n    * @param from The object containing the start values.\n    * @param to The object containing the end values.\n    * @param duration The time in seconds to complete the tween.\n    * @param params An object containing parameters.\n    * @returns The tween instance.\n    */\n    constructor( from: Object, to: Object, duration: number, params?: Params );\n    constructor( to: Object, duration: number, params?: Params );\n    constructor( params: Params );\n    constructor();\n    \n    /**\n    * @param time The time in seconds to complete the timer. Setting the `time` property makes the `from`, `to` and `duration` being ignored.\n    * @param onComplete The listener for the `onComplete` event.\n    */\n    constructor( time: number, onComplete: Callback, params?: Params );\n\n    constructor( ...args: any[] ) {\n      const argsCount = args.length;\n      let types: string[] = [];\n      for ( var i=0; i<argsCount; i++ ) {\n        types[i] = typeof args[i];\n      }\n      let params: any = {};\n\n      if ( (argsCount === 3 || argsCount === 4) && types[0] === \"object\" && types[1] === \"object\" && types[2] === \"number\" ) {\n        params = args[3] || {};\n        params.from = args[0];\n        params.to = args[1];\n        params.duration = args[2];\n      }\n      else if ( (argsCount === 2 || argsCount === 3) && types[0] === \"object\" && types[1] === \"number\" ) {\n        params = args[2] || {};\n        params.to = args[0];\n        params.duration = args[1];\n      }\n      else if ( (argsCount === 2 || argsCount === 3) && types[0] === \"number\" && types[1] === \"function\" ) {\n        params = args[2] || {};\n        params.time = args[0];\n        params.onComplete = args[1];\n      }\n      else if ( argsCount === 1 && args[0] !== null && typeof args[0] === \"object\") {\n        params = args[0] || {};\n      }\n      else if (argsCount > 0) {\n        console.error( \"fTween.Tween(): Unknow constructor with \"+argsCount+\" arguments, see details below\" );\n        for (let i = 0; i < args.length; i++) {\n          console.log( \"argument #\"+i+\": type=\"+types[i]+\" value=\", args[i]);\n        }\n      }\n\n      if (params.onComplete === undefined) {\n        /*var self = this;\n        this.__inner.onComplete( function() { \n          self._isComplete = true; \n          if (self._destroyOnComplete === true)\n            self.destroy();\n        } );*/\n        this.__inner.onComplete( () => { \n          this._isComplete = true; \n          if (this._destroyOnComplete === true)\n            this.destroy();\n        } );\n      }\n\n      const start = params.start;\n      delete params.start;\n      \n      if ( Object.keys( params ).length > 0 ) {\n        this.set( params );\n      }\n\n      if ( this._to !== undefined && this._duration > 0 &&\n        (start === undefined || start >= 0) ) {\n        this.start( start );\n      }\n    }\n\n    // --------------------------------------------------------------------------------\n    // methods\n\n    /**\n    * Sets several of the tweener's properties at once.\n    * @param params The list of parameters.\n    */\n    set( params: Params ) {\n      params = copyObject( params );\n\n      if ( params.from !== undefined ) {\n        this.from = params.from;\n        delete params.from;\n      }\n      if ( params.to !== undefined ) {\n        this.to = params.to;\n        delete params.to;\n      }\n      \n      const start = params.start;\n      delete params.start;\n      \n      for ( let key in params ) {\n        if ( eventNames.indexOf( key ) !== -1 ) {\n          this.on( key, params[ key ] )\n        }\n        else {\n          // TODO FIXME: can a local property can be set this way ?\n          this[ key ] = params[ key ];\n        }\n      }\n\n      if ( typeof start === \"number\" && start >= 0 ) {\n        this.start( start );\n      }\n    }\n\n    /**\n    * Make the provided callback be called when the specified event occurs.\n    * @param eventName The event name.\n    * @param callback The callback function.\n    * @returns The tween instance.\n    */\n    on( eventName: \"onStart\", callback?: Callback ): Tween;\n    on( eventName: \"onPause\", callback?: Callback ): Tween;\n    on( eventName: \"onResume\", callback?: Callback ): Tween;\n    on( eventName: \"onUpdate\", callback?: UpdateCallback ): Tween;\n    on( eventName: \"onLoopComplete\", callback?: LoopCompleteCallback ): Tween;\n    on( eventName: \"onComplete\", callback?: Callback ): Tween;\n    on( eventName: \"onStop\", callback?: Callback ): Tween;\n    on( eventName: string, callback?: Function ): Tween;\n\n    on( eventName: string, callback?: Function ): Tween {\n      const eventPos = shortEventNames.indexOf( eventName );\n      eventName = eventNames[ eventPos ] || eventName; // transform short event name in \"long\" name or leave it as it is.\n      if ( eventNames.indexOf( eventName ) === -1 ) {\n        console.error( \"fTween.Tween.on(): ERROR: wrong event name: \"+eventName+\". Expected values are:\", shortEventNames, eventNames );\n        return;\n      }\n      if (callback === undefined)\n        callback = null;\n      if (eventName === \"onComplete\") {\n        const userCallback = callback;\n        // var self = this;\n        callback = () => {\n          this._isComplete = true;\n          if (userCallback !== null)\n            userCallback.call( this );\n          if (this._destroyOnComplete === true)\n            this.destroy();\n        };\n      }\n      this.__inner[ eventName ]( callback );\n      return this;\n    }\n\n    /**\n    * Starts the tween. <br>\n    * Tweens are automatically started after their creation if the duration and the `to` object are supplied. You can prevent this by setting the `start` property to a negative value in the constructor's `params` argument. \n    * @param time The time (a timetamp in milliseconds) at which to start the tween.\n    */\n    start( time?: number ) {\n      // console.log(\"ftween start\", this);\n      if ( this._to === undefined || this._duration === 0  ) {\n        console.log( \"fTween.Tween.start(): ERROR: Can't start the tweener now because The 'to' object and/or the duration have not been set: \", this._to, this._duration );\n        return;\n      }\n\n      if ( this._from === undefined ) {\n        this.from = {};\n      }\n\n      this._isComplete = false;\n      if ( time !== undefined ) {\n        if ( time < 0 ) {\n          time = 0\n        }\n      }\n      this.__inner.start( time );\n    }\n\n    /**\n    * Pause the tween, stopping the update of its values.\n    */\n    pause() { \n      this._isPaused = true;\n      this.__inner.pause(); \n    }\n\n    /**\n    * Resume the tween after it has been paused, resuming the update of its values where they have been paused.\n    */\n    resume() { \n      this._isPaused = false;\n      this.__inner.resume(); \n    }\n\n    /**\n    * Stop the tween, stopping the update of its values.  <br>\n    * A stopped tween can not be resumed, but can be restarted by calling start() again, with unpredictable results.\n    */\n    stop() { this.__inner.stop(); }\n    \n    /**\n    * Stop the tween and all its chained tweens then remove all its listeners and de-reference as much objects as possible to let them be garbage collected.\n    */\n    destroy() {\n      this.__inner.destroy();\n      this.__inner = null;\n      this._from = null;\n      this._to = null;\n      this._isDestroyed = true;\n    }\n\n    /**\n    * Check that the provided value is not too big. <br>\n    * If that's the case, suppose that it is a number of milliseconds instead of seconds and display a warning. <br>\n    * Called by duration, delay and time setters.\n    * @param value The value.\n    * @param propName The name of the evaluated property.\n    */\n    private _checkMilliseconds( value: number, propName: string ) {\n      if ( value >= 500 ) {\n        console.warn( \"fTween.\"+propName+\": WARNING: The provided value '\"+value+\"' is superior to 500! The value has to be expressed in seconds, not in milliseconds. Are you sure you didn't meant the value to be '\"+value/1000+\"' seconds instead ?\" );\n      }\n    }\n\n    // --------------------------------------------------------------------------------\n    // properties\n\n    /**\n    * The `FTWEEN.Tween` instance that actually perform the tweening.\n    */\n    private __inner = new FTWEEN.Tween();\n\n    private _to: Object;\n    /**\n    * The `to` object containing the end values.\n    */\n    set to( to: Object ) {\n      this._to = to;\n      this.__inner.to( to );\n    }\n    get to(): Object { return this._to; }\n\n\n    private _duration: number = 0;\n    /**\n    * The time in seconds to complete the tween.\n    */\n    set duration( duration: number ) {\n      if ( duration < 0 ) {\n        duration = 0\n      }\n      this._checkMilliseconds( duration, \"duration\" );\n      this.__inner.duration( duration * 1000 );\n      this._duration = duration;\n    } \n    get duration(): number { return this._duration; }\n\n\n    /**\n    * The time in seconds to complete the timer. Setting the `time` property makes the `from`, `to` and `duration` being ignored.\n    */\n    set time( time: number ) {\n      if ( time < 0 ) {\n        time = 0\n      }\n      this._checkMilliseconds( time, \"time\" );\n      this.from = { elapsedTime: 0, remainingTime: time };\n      this.to = { elapsedTime: time, remainingTime: 0 };\n      this.duration = time;\n    }\n    get time(): number { return this._duration; }\n\n\n    private _from: Object; // from has to exist but is completely optionnal\n    /**\n    * The `from` object containing the start values.\n    */\n    set from( from: Object ) {\n      this._from = from;  \n      this.__inner.from( from );\n    }\n    get from(): Object { return this._from; }\n\n\n    private _isRelative: boolean = false;\n    /**\n    * Tell whether to consider number values in the to object as relative (true) or absolute (false). <br>\n    * Default is `false`.\n    */\n    set isRelative( isRelative: boolean ) { \n      this.__inner.isRelative( isRelative );\n      this._isRelative = isRelative; \n    }\n    get isRelative(): boolean { return this._isRelative; }\n\n\n    private _delay: number = 0;\n    /**\n    * The time in milliseconds before the tween's values actually starts to updates after the tween has been started. <br>\n    * Default is `0`.\n    */\n    set delay( delay: number ) { \n      if ( delay < 0 ) {\n        delay = 0;\n      }\n      this._checkMilliseconds( delay, \"delay\" );\n      this.__inner.delay( delay * 1000 );\n      this._delay = delay;\n    } \n    get delay(): number { return this._delay; }\n\n\n    private _repeat: number = 0;\n    /**\n    * The number of times the tween will repeat, after having completed once. <br>\n    * Settings `x` repeats is the same as setting `x+1` loops. <br>\n    * Default is `0`.\n    */\n    set repeat( repeat: number ) { \n      if ( repeat < 0 ) {\n        repeat = 0;\n      }\n      this.__inner.repeat( repeat );\n      this._repeat = repeat; \n    }\n    get repeat(): number { return this._repeat; }\n\n\n    /**\n    * The total number of times the tween will run. <br>\n    * Settings `x` loops is the same as setting `x-1` repeats. <br>\n    * Default is `1`.\n    */\n    set loops( loops: number ) { \n      if ( loops < 1 ) {\n        loops = 1;\n      }\n      this._repeat = loops - 1; \n      this.__inner.repeat( this._repeat );\n    }\n    get loops(): number { return this._repeat + 1; }\n\n\n    private _yoyo: boolean = false;\n    /**\n    * After having completed once and when repeat is strictly positive, tell whether the tween restart from its original state (false) (from 'from' to 'to', and repeat) or its current state (true) (from 'from' to 'to', then from 'to' to 'from', and repeat). <br>\n    * Default is `false`.\n    */\n    set yoyo( yoyo: boolean ) { \n      this.__inner.yoyo( yoyo );\n      this._yoyo = yoyo; \n    }\n    get yoyo(): boolean { return this._yoyo; }\n\n\n    private _easing: EasingFunction = null;\n    /**\n    * The easing function to use.\n    * Default is `fTween.Easing.Linear.None`.\n    */\n    set easing(fn: EasingFunction) { \n      this._easing = fn; \n      this.__inner.easing(this._easing);\n\n      let fnName: string = null;\n      if (fn !== null) {\n        for (let familly in fTween.Easing) {\n          for (let variant in fTween.Easing[familly]) {\n            if (fn === fTween.Easing[familly][variant]) {\n              fnName = familly+variant;\n              break;\n            }\n          }\n        }\n        if (fnName === null)\n          console.warn(\"fTween.Tween.easing property: An easing function has been set but it wasn't found in the fTween.Easing object. It is required if you want to set it by name, or get its name via the fTween.Tween.easingName property.\");\n      }\n      this._easingName = fnName;\n    }\n    get easing(): EasingFunction { return this._easing; }\n\n\n    private _easingName: string = null;\n    /**\n    * The name of the easing function to use, its \"path\" in the `fTween.Easing` object. <br>\n    * The name is composed of the familly followed by the variant. The `\"None\"` variant is optional. <br>\n    * Ie: `\"QuadraticIn\"` `\"CircularInOut\"` `\"Linear\"` `\"LinearNone\"`\n    * Default is `\"LinearNone\"`.\n    */\n    set easingName(name: string) {\n      name = name.charAt(0).toUpperCase() + name.slice(1); // make sure first letter is uppercase\n      const result = /^([_A-Z]{1}[a-z0-9_-]+)(([A-Z]{1}.+)?)$/.exec(name);\n      if (result !== null) {\n\n        const familly: Object = fTween.Easing[ result[1] ]; // if result isn't null, there is no reason the familly should be null, undefined or \"\"\n        if (familly !== undefined) {\n\n          const variant: string = result[2] || \"None\"; // if the variant is not supplied, result[2] === \"\"\n          const fn: EasingFunction = familly[variant];\n\n          if (fn !== undefined) {\n            this._easing = fn; \n            this.__inner.easing(this._easing);\n            this._easingName = name;\n            return;\n          }\n        }\n      }\n      console.warn(\"fTween.Tween.easingName property: No easing function found for name '${name}'. Nothing has been done.\", result);\n    }\n    get easingName(): string { return this._easingName; }\n\n\n    private _interpolation: InterpolationFunction = null;\n    /**\n    * The interpolation function to use. <br>\n    * Default is `fTween.Interpolation.Linear`.\n    */\n    set interpolation(fn: InterpolationFunction) {\n      this._interpolation = fn;\n      this.__inner.interpolation(this._interpolation);\n\n      let fnName: string = null;\n      if (fn !== null) {\n        for (let _fnName in fTween.Interpolation) {\n          if (fn === fTween.Interpolation[_fnName]) {\n            fnName = _fnName;\n            break;\n          }\n        }\n        if (fnName === null)\n          console.warn(\"fTween.Tween.interpolation property: An interpolation function has been set but it wasn't found in the fTween.Interpolation object. It is required if you want to set it by name, or get its name via the fTween.Tween.interpolationName property.\");\n      }\n      this._interpolationName = fnName;\n    }\n    get interpolation(): InterpolationFunction { return this._interpolation; }\n\n\n    private _interpolationName: string = null; // \"name\" of the interpolation function in the fTween.Interpolation object.\n    /**\n    * The name of interpolation function to use, its key in the `fTween.Interpolation` object. <br>\n    * Default is `\"Linear\"`.\n    */\n    set interpolationName(name: string) {\n      name = name.charAt(0).toUpperCase() + name.slice(1); // make sure first letter is uppercase\n      const fn = fTween.Interpolation[name];\n      if (fn !== undefined) {\n        this._interpolation = fn; \n        this.__inner.interpolation(this._interpolation);\n        this._interpolationName = name;\n      }\n      else     \n        console.error(\"fTween.Tween.interpolationName property: No interpolation function found in the fTween.Interpolation object for name '${name}'.\");\n    }\n    get interpolationName(): string { return this._interpolationName; }\n\n\n    private _isPaused: boolean = false;\n    /**\n    * The tween's paused state. Use the `pause()` and `resume()` methods to control the paused state. <br>\n    * Default is `false`.\n    */\n    get isPaused(): boolean { return this._isPaused; }\n\n\n    // (re)set to false in start()\n    // set to true in the onComplete callback set in the constructor\n    private _isComplete: boolean = false; \n    /**\n    * The tween's completed state.\n    * Default is `false`.\n    */\n    get isComplete(): boolean { return this._isComplete; }\n\n\n    private _destroyOnComplete: boolean = true;\n    /**\n    * Tell whether to destroy the tween once it has completed (true), or not (false). <br>\n    * Default is `true`.\n    */\n    set destroyOnComplete( destroyOnComplete: boolean ) {\n      this._destroyOnComplete = destroyOnComplete;\n    }\n    get destroyOnComplete(): boolean { return this._destroyOnComplete; }\n\n\n    private _isDestroyed: boolean = false; \n    /**\n    * The tween's destroyed state. Call destroy() to destroy a tween and free some objects for GC. <br>\n    * Default is `false`.\n    */\n    get isDestroyed(): boolean { return this._isDestroyed; }\n\n  } // end of fTween.Tween class\n\n  // --------------------------------------------------------------------------------\n\n  /**\n  * Signature for the easing functions. All available easing functions can be found inside the `fTween.Easing` object.\n  */\n  export interface EasingFunction {\n    /**\n    * @param k The progression toward the end (between 0 and 1).\n    * @returns The eased progression (between 0 and 1), taking the easing into account.\n    */\n    (k: number): number;\n  }\n\n  /**\n  * Signature for the interpolation functions. All available interpolation functions can be found inside the `fTween.Interpolation` object.\n  */\n  export interface InterpolationFunction {\n    /**\n    * @param v The list of values to interpolate through.\n    * @param k The progression toward the end (between 0 and 1).\n    * @returns The interpolatied value.\n    */\n    (v: number[], k: number): number;\n  }\n\n  /**\n  * Signature for all callbacks except `onUpdate`, to be set via the `fTween.Tween.on()` function.\n  */\n  export interface Callback {\n    (): void;\n  }\n\n  /**\n  * Signature for the `onUpdate` callback, to be set via the `fTween.Tween.on()` function.\n  */\n  export interface UpdateCallback {\n    /**\n    * @param progression The progression of the tween as a number between 0 and 1.\n    */\n    (progression: number): void;\n  }\n\n  /**\n  * Signature for the `onLoopComplete` callback, to be set via the `fTween.Tween.on()` function.\n  */\n  export interface LoopCompleteCallback {\n    /**\n    * @param remainingLoops The number of loops the tween has still to run.\n    */\n    (remainingLoops: number): void;\n  }\n\n  /**\n  * Interface for the `params` argument of `fTween.Tween`'s constructors and `set()` function.\n  */\n  export interface Params {\n    /**\n    * The object containing the start values.\n    */\n    from?: Object;\n    /** \n    * The object containing the end values.\n    */\n    to?: Object;\n    /**\n    * The time in seconds to complete the tween.\n    */\n    duration?: number;\n    /**\n    * The time in seconds to complete the timer. Setting the `time` property makes the `from`, `to` and `duration` being ignored.\n    */\n    time?: number;\n    /**\n    * Tell whether to consider number values in the to object as relative (true) or absolute (false).\n    */\n    isRelative?: boolean;\n    /**\n    * The time in seconds before the tween's values actually starts to updates after the tween has been started.\n    */\n    delay?: number;\n    /**\n    * The number of times the tween will repeat, __after having completed once__. <br>\n    * Settings `x` repeats is the same as setting `x+1` loops.\n    */\n    repeat?: number;\n    /**\n    * The total number of times the tween will run. <br>\n    * Settings `x` loops is the same as setting `x-1` repeats.\n    */\n    loops?: number;\n    /**\n    * After having completed once and when repeat is strictly positive, tell whether the tween restart from its original state (false) (from 'from' to 'to', and repeat) or its current state (true) (from 'from' to 'to', then from 'to' to 'from', and repeat).\n    */\n    yoyo?: boolean;\n    /**\n    * The easing function to use.\n    */\n    easing?: EasingFunction;\n    /**\n    * The name of the easing function to use, its \"path\" in the `fTween.Easing` object. <br>\n    * The name is composed of the familly followed by the variant. The `\"None\"` variant is optional. <br>\n    * Ie: `\"QuadraticIn\"` `\"CircularInOut\"` `\"Linear\"` `\"LinearNone\"`\n    */\n    easingName?: string;\n    /**\n    * The interpolation function to use.\n    */\n    interpolation?: InterpolationFunction;\n    /**\n    * The name of interpolation function to use, its key in the `fTween.Interpolation` object.\n    */\n    interpolationName?: string;\n    /**\n    * Tell whether to destroy the tween once it has completed (true), or not (false).\n    */\n    destroyOnComplete?: boolean;\n    /**\n    * The callback for the `onStart` event.\n    */\n    onStart?: Callback;\n    /**\n    * The callback for the `onPause` event.\n    */\n    onPause?: Callback;\n    /**\n    * The callback for the `onResume` event.\n    */\n    onResume?: Callback;\n    /**\n    * The callback for the `onUpdate` event.\n    */\n    onUpdate?: UpdateCallback;\n    /**\n    * The callback for the `onLoopComplete` event.\n    */\n    onLoopComplete?: LoopCompleteCallback;\n    /**\n    * The callback for the `onComplete` event.\n    */\n    onComplete?: Callback;\n    /**\n    * The callback for the `onStop` event.\n    */\n    onStop?: Callback;\n    /**\n    * The time (a timetamp in milliseconds) at which to start the tween. Tweens are automatically started at the time they are created, so you may set the property to a negative value to prevent it to be started at all, or set any other time you like. \n    */\n    start?: number;\n  }\n} // end of fTween namespace\n\n// expose to the runtime\n(window as any).fTween = fTween;\n".replace("<reference path=", "<_reference path="),
  defs: "// fTween plugin\n// https://github.com/florentpoujol/superpowers-game-ftween-plugin\n// Module and class for easy tweening (animation of values).\n// Wrapper around ftween.js (the FTWEEN module), a fork of tween.js.\n\n// Documentation:\n// http://florentpoujol.github.io/superpowers-game-ftween-plugin\n\n// You can also access the documentation offline in the plugin's \"public/docs\" folder \n// or via the \"Plugins documentation\" tool provided by the \"Plugins documentation\" plugin: https://github.com/florentpoujol/superpowers-common-pluginsdocs-plugin\n\ndeclare namespace fTween {\n  var Easing: FTWEEN.Easings;\n  var Interpolation: FTWEEN.Interpolations;\n\n  class Tween {\n    constructor(from: Object, to: Object, duration: number, params?: Params);\n    constructor(to: Object, duration: number, params?: Params);\n    constructor(time: number, onComplete: Callback, params?: Params);\n    constructor(params: Params);\n    constructor();\n\n    set(params: Params);\n\n    on(eventName: \"onStart\", callback?: Callback): Tween;\n    on(eventName: \"onPause\", callback?: Callback): Tween;\n    on(eventName: \"onResume\", callback?: Callback): Tween;\n    on(eventName: \"onUpdate\", callback?: UpdateCallback): Tween;\n    on(eventName: \"onLoopComplete\", callback?: LoopCompleteCallback): Tween;\n    on(eventName: \"onComplete\", callback?: Callback): Tween;\n    on(eventName: \"onStop\", callback?: Callback): Tween;\n    on(eventName: string, callback?: Function): Tween;\n\n    start(time?: number);\n    pause();\n    resume();\n    stop();\n    destroy();\n\n    to: Object;\n    duration: number;\n    time: number;\n    from: Object;\n    isRelative: boolean;\n    delay: number;\n    repeat: number;\n    loops: number;\n    yoyo: boolean;\n    easing: EasingFunction;\n    interpolation: InterpolationFunction;\n    isPaused: boolean;\n    isCompleted: boolean;\n    isDestroyed: boolean;\n  } \n  \n  interface Params {\n    from?: Object;\n    to?: Object;\n    duration?: number;\n    time?: number;\n    isRelative?: boolean;\n    delay?: number;\n    repeat?: number;\n    loops?: number;\n    yoyo?: boolean;\n    easing?: EasingFunction;\n    easingName?: string;\n    interpolation?: InterpolationFunction;\n    interpolationName?: string;\n    destroyOnComplete?: boolean;\n    onStart?: Callback;\n    onPause?: Callback;\n    onResume?: Callback;\n    onUpdate?: UpdateCallback;\n    onLoopComplete?: LoopCompleteCallback;\n    onComplete?: Callback;\n    onStop?: Callback;\n    start?: number;\n  }\n\n  interface EasingFunction {\n    (k:number): number;\n  }\n  interface InterpolationFunction {\n    (v:number[], k:number): number;\n  }\n\n  interface Callback {\n    (): void;\n  }\n  interface UpdateCallback {\n    (progression:number): void;\n  }\n  interface LoopCompleteCallback {\n    (remainingLoops:number): void;\n  }\n}\n"
});

},{}]},{},[1]);
